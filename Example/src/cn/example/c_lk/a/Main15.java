package cn.example.c_lk.a;

/*1256. 第n个数位
中文
English

找出无限正整数数列1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...中的第n个数位。
样例

样例 1:

输入：3
输出：3

样例 2:

输入：11
输出：0
解析：数字序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 第11位是0

注意事项

    n是一个正整数，并且不会超出32位有符号整数的范围（n < 2^31）。

*/
/*1.从位数为1开始统计不同的位数的数字所占的总位数，如0~9一共占10位，10~99一共占180位…并进行累加，一旦累加的和超过给定的位数，可以找到目标数字的一个大概范围，再进一步进行分析。
例子：
比如找，查找序列的第1001位是什么数字？
1.序列的前10位是0~9这10个数字，没有查过要查找的位数1001
2.然后是两位的数字10~99一共占180位，累加190位也没有超过1001
3.三位的数字100~999一共占2700位，累加起来2890超过了1001，所以1001位所在的数字是一个三位数。
4.已知三位数之前的数字总共占去190位，所以要查找的是三位数字中的第（1001-190）=811位
5.811/3 = 270（余1），所以找的是100+270-1 = 369后面的数字的第二位（这里要注意，从0开始计数），即370的第二位即7*/
public class Main15 {
    public static void main(String[] args) {
        System.out.println(findNthDigit(13));
    }

    public static int findNthDigit(int n) {
        long i = 1, s = 9, base = 1;//i位数 base（比如n=13 base=10）
        while (n > i * s) {//判断是几位数
            n -= i * s;
            i++;
            s *= 10;
            base *= 10;
        }
        int num = (int) ((n + i - 1) / i - 1 + base);//比如：n=13,求出他在2位数中的11
        int mod = (int) (n % i);//比如：求出他在2位数的第11个数的第1位数字（从零开始计算）
        if (mod==0){
            mod= (int) i;
        }
        for (int j = 0; j <i-mod; j++) {
            num /= 10;
        }
        return num % 10;
    }
}


